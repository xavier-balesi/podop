{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"Linux/MacWindows <pre><code>curl -sSL https://pdm-project.org/install-pdm.py | python3 -\n</code></pre> <pre><code>(Invoke-WebRequest -Uri https://pdm-project.org/install-pdm.py -UseBasicParsing).Content | py -\n</code></pre>"},{"location":"reference/","title":"Reference","text":""},{"location":"reference/#back.__main__","title":"<code>__main__</code>","text":"<p>Main module executed by the Dockerfile.</p>"},{"location":"reference/#back.__main__.MultiServer","title":"<code>MultiServer</code>","text":"<p>             Bases: <code>Server</code></p> <p>Server listening on one port and accepting other servers in parallel.</p> Source code in <code>src/back/__main__.py</code> <pre><code>class MultiServer(Server):\n    \"\"\"Server listening on one port and accepting other servers in parallel.\"\"\"\n\n    def __init__(self, on_shutdown, *args, **kwargs) -&gt; None:\n        self.on_shutdown = on_shutdown\n        super().__init__(*args, **kwargs)\n\n    async def async_run(self, sockets=None) -&gt; None:\n        \"\"\"Same implementation as :meth:`~Server.run` but in async.\"\"\"\n        self.config.setup_event_loop()\n        await self.serve(sockets=sockets)\n\n    async def shutdown(\n        self,\n        *args,\n        **kwargs,\n    ) -&gt; None:  # pragma: no cover (can only be called in prod)\n        \"\"\"Shutdown the server and notify the others.\"\"\"\n        self.on_shutdown()\n        cancel_all_tasks()\n        return await super().shutdown(*args, **kwargs)\n</code></pre>"},{"location":"reference/#back.__main__.MultiServer.async_run","title":"<code>async_run(sockets=None)</code>  <code>async</code>","text":"<p>Same implementation as :meth:<code>~Server.run</code> but in async.</p> Source code in <code>src/back/__main__.py</code> <pre><code>async def async_run(self, sockets=None) -&gt; None:\n    \"\"\"Same implementation as :meth:`~Server.run` but in async.\"\"\"\n    self.config.setup_event_loop()\n    await self.serve(sockets=sockets)\n</code></pre>"},{"location":"reference/#back.__main__.MultiServer.shutdown","title":"<code>shutdown(*args, **kwargs)</code>  <code>async</code>","text":"<p>Shutdown the server and notify the others.</p> Source code in <code>src/back/__main__.py</code> <pre><code>async def shutdown(\n    self,\n    *args,\n    **kwargs,\n) -&gt; None:  # pragma: no cover (can only be called in prod)\n    \"\"\"Shutdown the server and notify the others.\"\"\"\n    self.on_shutdown()\n    cancel_all_tasks()\n    return await super().shutdown(*args, **kwargs)\n</code></pre>"},{"location":"reference/#back.__main__.cancel_all_tasks","title":"<code>cancel_all_tasks(exclude_current=False)</code>","text":"<p>Cancel all asyncio tasks to force exiting on Ctrl+C. Necessary only because of the game infinite loop. TODO: find cleaner solution.</p> Source code in <code>src/back/__main__.py</code> <pre><code>def cancel_all_tasks(exclude_current=False) -&gt; None:\n    \"\"\"Cancel all asyncio tasks to force exiting on Ctrl+C.\n    Necessary only because of the game infinite loop.\n    TODO: find cleaner solution.\n    \"\"\"\n    all_tasks = asyncio.all_tasks()\n    if exclude_current and (current_task := asyncio.current_task()):\n        all_tasks.remove(current_task)\n    for task in all_tasks:\n        task.cancel()\n</code></pre>"},{"location":"reference/#back.__main__.exit_application","title":"<code>exit_application()</code>","text":"<p>Exit the application.</p> Source code in <code>src/back/__main__.py</code> <pre><code>def exit_application() -&gt; None:\n    \"\"\"Exit the application.\"\"\"\n    log.info(\"exiting the backend\")\n    for server in servers:\n        server.should_exit = True\n</code></pre>"},{"location":"reference/#back.__main__.main","title":"<code>main()</code>  <code>async</code>","text":"<p>Main function executed by the Dockerfile.</p> Source code in <code>src/back/__main__.py</code> <pre><code>async def main() -&gt; None:\n    \"\"\"Main function executed by the Dockerfile.\"\"\"\n    app_config: ApplicationConfig = ApplicationConfig()\n\n    for app, port in (\n        (\"back.api.routes:app\", api_port := app_config.api.port),\n        (\n            \"back.api.monitoring:app\",\n            monitoring_port := app_config.api.monitoring_port,\n        ),\n    ):\n        # WARNING: when providing the default log_config, it disabled all existing loggers, and we loose some logs.\n        config = Config(app, host=\"0.0.0.0\", port=port, log_config=None)\n        servers.append(MultiServer(config=config, on_shutdown=exit_application))\n\n    log.info(\n        f\"the backend is ready and listen on {api_port} (API) and {monitoring_port} (monitoring)\",\n    )\n    # By using a dedicated port for monitoring features (healthcheck, metrics, changing log level, etc.),\n    # and not exposing it, the front can't have access to these features. It's more risky to expect\n    # an API Gateway blocking the access to /monitoring path.\n    await asyncio.gather(*(server.async_run() for server in servers))\n</code></pre>"},{"location":"reference/#back.api","title":"<code>api</code>","text":""},{"location":"reference/#back.api.monitoring","title":"<code>monitoring</code>","text":"<p>main module executed by the Dockerfile.</p>"},{"location":"reference/#back.api.monitoring.healthcheck","title":"<code>healthcheck()</code>  <code>async</code>","text":"<p>Healthcheck for Kubernetes.</p> Source code in <code>src/back/api/monitoring.py</code> <pre><code>@app.get(\"/monitoring/health\")\nasync def healthcheck() -&gt; int:\n    \"\"\"Healthcheck for Kubernetes.\"\"\"\n    return 200\n</code></pre>"},{"location":"reference/#back.api.routes","title":"<code>routes</code>","text":""},{"location":"reference/#back.api.routes.websocket_endpoint","title":"<code>websocket_endpoint(websocket)</code>  <code>async</code>","text":"<p>Start a new game by connecting to a websocket.</p> <p>The game runs as fast as possible. Eventually slow it down by using the <code>turn_interval</code> config. Spying the game by sampling the game resources at a given framerate (see <code>framerate</code> config). Game information are communicated in JSON format by a websocket. A complete resource history is sent when the game is over.</p> Source code in <code>src/back/api/routes.py</code> <pre><code>@app.websocket(\"/ws\")\nasync def websocket_endpoint(websocket: WebSocket) -&gt; None:\n    \"\"\"Start a new game by connecting to a websocket.\n\n    The game runs as fast as possible. Eventually slow it down by using the `turn_interval` config.\n    Spying the game by sampling the game resources at a given framerate (see `framerate` config).\n    Game information are communicated in JSON format by a websocket.\n    A complete resource history is sent when the game is over.\n    \"\"\"\n    log.info(\"Client connected\")\n    await websocket.accept()\n    game = Game()\n\n    async def notify_front() -&gt; None:\n        while game.running:\n            await asyncio.sleep(1.0 / api_config.framerate)\n\n            # Sampling number of game resources on each frame.\n            front_msg: str = game.get_counts().json()\n            try:\n                # Using a websocket to eventually pilot the trading strategy manually from the web client.\n                await websocket.send_text(front_msg)\n            except WebSocketDisconnect as e:\n                log.warning(f\"Client disconnected: {e!r}\", exc_info=True)\n                return\n\n        # Send the complete resource history when the game is over.\n        counts_history: CountsHistory = game.get_counts_history()\n        # TODO: timeit orjson.dumps(model.dict(exclude_none=True))\n        front_msg = counts_history.json(exclude_none=True)\n        # We can also debug the backend without frontend by doing:\n        #   python -m websockets 'ws://localhost:8080/ws'\n        # and displaying the desired data in color with:\n        #   print_json(data=counts_history.dict(exclude_none=True))\n        # from rich module, for example.\n        try:\n            await websocket.send_text(front_msg)\n        except WebSocketDisconnect as e:\n            log.warning(f\"Client disconnected: {e!r}\", exc_info=True)\n            return\n\n    # Run the game and spy the game in parallel, by sampling the inventory.\n    await asyncio.gather(game.run(), notify_front())\n</code></pre>"},{"location":"reference/#back.config","title":"<code>config</code>","text":""},{"location":"reference/#back.config.ApiConfig","title":"<code>ApiConfig</code>","text":"<p>             Bases: <code>CamelBaseModel</code></p> <p>HTTP servers configuration.</p> Source code in <code>src/back/config.py</code> <pre><code>class ApiConfig(CamelBaseModel):\n    \"\"\"HTTP servers configuration.\"\"\"\n\n    port: int = 8000\n    monitoring_port: int = 9000\n    framerate: int = (\n        # Number of notification per second sent by the backend to the frontend.\n        # Could be adapted according to the \"turn_interval\" parameter.\n        30\n    )\n</code></pre>"},{"location":"reference/#back.config.ApplicationConfig","title":"<code>ApplicationConfig</code>","text":"<p>             Bases: <code>CamelBaseModel</code></p> <p>Application configuration.</p> Source code in <code>src/back/config.py</code> <pre><code>class ApplicationConfig(CamelBaseModel):\n    \"\"\"Application configuration.\"\"\"\n\n    api: ApiConfig = ApiConfig()\n    game: GameConfig = GameConfig()\n</code></pre>"},{"location":"reference/#back.config.CamelBaseModel","title":"<code>CamelBaseModel</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>Base model class to use the lower camel case like the other config files in the helmfiles.</p> Source code in <code>src/back/config.py</code> <pre><code>class CamelBaseModel(BaseModel):\n    \"\"\"Base model class to use the lower camel case like the other config files in the helmfiles.\"\"\"\n\n    class Config:  # pylint: disable=missing-class-docstring\n        alias_generator = to_lower_camel_case\n</code></pre>"},{"location":"reference/#back.config.GameConfig","title":"<code>GameConfig</code>","text":"<p>             Bases: <code>CamelBaseModel</code></p> <p>Game configuration.</p> Source code in <code>src/back/config.py</code> <pre><code>class GameConfig(CamelBaseModel):\n    \"\"\"Game configuration.\"\"\"\n\n    # Using ints to avoid float precision errors (using decimal module is less direct).\n    move_duration: int = 5000  # in ms\n    mine_foo_duration: int = 1000  # in ms\n    mine_bar_duration_min: int = 500  # in ms\n    mine_bar_duration_max: int = 2000  # in ms\n    forge_foobar_duration: int = 2000  # in ms\n    forge_foobar_success_rate: int = 60  # in percent\n    sell_foobar_duration: int = 10000  # in ms\n    sell_foobar_max_count: int = 5\n    money_for_foobar: int = 1  # in euros\n    buy_robot_duration: int = 0  # in ms\n    money_for_robot: int = 3  # number of euros to buy a robot\n    foo_for_robot: int = 6  # number of foo to buy a robot\n    min_robots: int = 2  # the game starts with this number of robots\n    max_robots: int = 30  # the game ends when reaching this number of robots\n    turn_duration: int = (\n        10  # duration of one turn in ms, the scheduler jump with this duration\n    )\n    turn_interval: int = (\n        0  # interval between turns in ms, increase to slow down the game\n    )\n</code></pre>"},{"location":"reference/#back.config.to_lower_camel_case","title":"<code>to_lower_camel_case(string)</code>","text":"<p>Return the lower camel case version of the input string as used in helmfiles.</p> Source code in <code>src/back/config.py</code> <pre><code>def to_lower_camel_case(string: str) -&gt; str:\n    \"\"\"Return the lower camel case version of the input string as used in helmfiles.\"\"\"\n    tokens = string.split(\"_\")\n    return tokens[0] + \"\".join(token.capitalize() for token in tokens[1:])\n</code></pre>"},{"location":"reference/#back.controllers","title":"<code>controllers</code>","text":""},{"location":"reference/#back.controllers.game","title":"<code>game</code>","text":""},{"location":"reference/#back.controllers.game_stats_mixin","title":"<code>game_stats_mixin</code>","text":""},{"location":"reference/#back.controllers.player","title":"<code>player</code>","text":""},{"location":"reference/#back.controllers.player.Player","title":"<code>Player</code>","text":"<p>Mining gamer or trader, that is the question.</p> Source code in <code>src/back/controllers/player.py</code> <pre><code>class Player:\n    \"\"\"Mining gamer or trader, that is the question.\"\"\"\n</code></pre>"},{"location":"reference/#back.controllers.player.RandomStrategyPlayer","title":"<code>RandomStrategyPlayer</code>","text":"<p>             Bases: <code>Player</code></p> <p>Player that plays randomly. Many random games might help finding good strategies.</p> Source code in <code>src/back/controllers/player.py</code> <pre><code>class RandomStrategyPlayer(Player):\n    \"\"\"Player that plays randomly.\n    Many random games might help finding good strategies.\n    \"\"\"\n\n    __slots__ = [\"_game\"]\n\n    def __init__(self, game: \"Game\") -&gt; None:\n        self._game: Game | None = game\n\n    def destroy(self) -&gt; None:\n        \"\"\"Destructor method.\n\n        Not using __del__ because it notifies when the object is garbage collected,\n        but it may not be called with cyclic references. It's not deterministic, so it's not\n        compatible to avoid memory leaks.\n        In cpython, __del__ is in practice called when there is no more reference to the object,\n        but with PyPy it's delayed for performances.\n        \"\"\"\n        self._game = None\n\n    def trade_in_live(self) -&gt; None:\n        \"\"\"Play each time the game changes.\"\"\"\n        if (game := self._game) is None:\n            log.warning(\"The game is detached fom the player.\")\n            return\n        inventory = game.get_inventory()\n        for robot in inventory.robots:\n            if robot.action != Action.WAITING_FOR_ORDER:\n                continue\n\n            # It's always possible to mine foo or bar.\n            possible_actions = [robot.mine_foo, robot.mine_bar]\n\n            # Can we forge a foobar?\n            if inventory.get_foo(lock=False) and inventory.get_bar(lock=False):  # type: ignore\n                possible_actions.append(robot.forge_foobar)\n\n            # Can we sell a random count of foobar?\n            sell_count = randint(1, game_config.sell_foobar_max_count)\n            if inventory.get_foobars(count=sell_count, lock=False):  # type: ignore\n                possible_actions.append(partial(robot.sell_foobar, count=sell_count))\n\n            # Can we buy a robot?\n            if inventory.money &gt;= game_config.money_for_robot and inventory.get_foos(  # type: ignore\n                count=game_config.foo_for_robot,\n                lock=False,\n            ):\n                possible_actions.append(robot.buy_robot)\n\n            # Choose a random action that respect game rules.\n            random_action = choice(possible_actions)\n            log.debug(f\"player choose {random_action} while {game.get_counts()}\")\n            random_action()\n</code></pre>"},{"location":"reference/#back.controllers.player.RandomStrategyPlayer.destroy","title":"<code>destroy()</code>","text":"<p>Destructor method.</p> <p>Not using del because it notifies when the object is garbage collected, but it may not be called with cyclic references. It's not deterministic, so it's not compatible to avoid memory leaks. In cpython, del is in practice called when there is no more reference to the object, but with PyPy it's delayed for performances.</p> Source code in <code>src/back/controllers/player.py</code> <pre><code>def destroy(self) -&gt; None:\n    \"\"\"Destructor method.\n\n    Not using __del__ because it notifies when the object is garbage collected,\n    but it may not be called with cyclic references. It's not deterministic, so it's not\n    compatible to avoid memory leaks.\n    In cpython, __del__ is in practice called when there is no more reference to the object,\n    but with PyPy it's delayed for performances.\n    \"\"\"\n    self._game = None\n</code></pre>"},{"location":"reference/#back.controllers.player.RandomStrategyPlayer.trade_in_live","title":"<code>trade_in_live()</code>","text":"<p>Play each time the game changes.</p> Source code in <code>src/back/controllers/player.py</code> <pre><code>def trade_in_live(self) -&gt; None:\n    \"\"\"Play each time the game changes.\"\"\"\n    if (game := self._game) is None:\n        log.warning(\"The game is detached fom the player.\")\n        return\n    inventory = game.get_inventory()\n    for robot in inventory.robots:\n        if robot.action != Action.WAITING_FOR_ORDER:\n            continue\n\n        # It's always possible to mine foo or bar.\n        possible_actions = [robot.mine_foo, robot.mine_bar]\n\n        # Can we forge a foobar?\n        if inventory.get_foo(lock=False) and inventory.get_bar(lock=False):  # type: ignore\n            possible_actions.append(robot.forge_foobar)\n\n        # Can we sell a random count of foobar?\n        sell_count = randint(1, game_config.sell_foobar_max_count)\n        if inventory.get_foobars(count=sell_count, lock=False):  # type: ignore\n            possible_actions.append(partial(robot.sell_foobar, count=sell_count))\n\n        # Can we buy a robot?\n        if inventory.money &gt;= game_config.money_for_robot and inventory.get_foos(  # type: ignore\n            count=game_config.foo_for_robot,\n            lock=False,\n        ):\n            possible_actions.append(robot.buy_robot)\n\n        # Choose a random action that respect game rules.\n        random_action = choice(possible_actions)\n        log.debug(f\"player choose {random_action} while {game.get_counts()}\")\n        random_action()\n</code></pre>"},{"location":"reference/#back.controllers.robot","title":"<code>robot</code>","text":""},{"location":"reference/#back.controllers.trading_resource_game","title":"<code>trading_resource_game</code>","text":""},{"location":"reference/#back.controllers.trading_resource_game.TradingResourceGame","title":"<code>TradingResourceGame</code>","text":"<p>Interface for a trading resource game.</p> <p>NB: Trading resources generates transactions.</p> Source code in <code>src/back/controllers/trading_resource_game.py</code> <pre><code>class TradingResourceGame:\n    \"\"\"Interface for a trading resource game.\n\n    NB: Trading resources generates transactions.\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        super().__init__()\n        self._inventory: Inventory = Inventory()\n        self.running: bool = True\n\n        # Transactions are like \"gold source\" outputs of the game.\n        self._transactions: list[Transaction] = []\n\n    def get_inventory(self) -&gt; Inventory:\n        return self._inventory\n\n    def on_new_transaction(self, transaction: Transaction) -&gt; None:\n        \"\"\"The game is notified when a transaction of resources happens.\"\"\"\n        self._transactions.append(transaction)\n</code></pre>"},{"location":"reference/#back.controllers.trading_resource_game.TradingResourceGame.on_new_transaction","title":"<code>on_new_transaction(transaction)</code>","text":"<p>The game is notified when a transaction of resources happens.</p> Source code in <code>src/back/controllers/trading_resource_game.py</code> <pre><code>def on_new_transaction(self, transaction: Transaction) -&gt; None:\n    \"\"\"The game is notified when a transaction of resources happens.\"\"\"\n    self._transactions.append(transaction)\n</code></pre>"},{"location":"reference/#back.models","title":"<code>models</code>","text":""},{"location":"reference/#back.models.errors","title":"<code>errors</code>","text":""},{"location":"reference/#back.models.errors.GameError","title":"<code>GameError</code>","text":"<p>             Bases: <code>Exception</code></p> <p>Base class for Foobartory exceptions.</p> Source code in <code>src/back/models/errors.py</code> <pre><code>class GameError(Exception):\n    \"\"\"Base class for Foobartory exceptions.\"\"\"\n</code></pre>"},{"location":"reference/#back.models.errors.RobotBusyError","title":"<code>RobotBusyError</code>","text":"<p>             Bases: <code>GameError</code></p> <p>The robot cannot do anything for now.</p> Source code in <code>src/back/models/errors.py</code> <pre><code>class RobotBusyError(GameError):\n    \"\"\"The robot cannot do anything for now.\"\"\"\n</code></pre>"},{"location":"reference/#back.models.errors.SellError","title":"<code>SellError</code>","text":"<p>             Bases: <code>GameError</code></p> <p>Error while selling foobars.</p> Source code in <code>src/back/models/errors.py</code> <pre><code>class SellError(GameError):\n    \"\"\"Error while selling foobars.\"\"\"\n</code></pre>"},{"location":"reference/#back.models.inventory","title":"<code>inventory</code>","text":""},{"location":"reference/#back.models.inventory.Inventory","title":"<code>Inventory</code>","text":"<p>Inventory of all game data models. Act as the :class:<code>~back.controllers.Game</code> data model.</p> Source code in <code>src/back/models/inventory.py</code> <pre><code>class Inventory:\n    \"\"\"Inventory of all game data models.\n    Act as the :class:`~back.controllers.Game` data model.\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        # Complete class methods.\n        for ressource_name in IncrIdRessources.__args__:  # type: ignore\n            ressource_name = ressource_name.__name__.lower()\n            setattr(\n                self,\n                \"get_\" + ressource_name,\n                partial(self.get_ressource, ressource_name),\n            )\n            setattr(\n                self,\n                f\"get_{ressource_name}s\",\n                partial(self.get_ressources, ressource_name),\n            )\n\n        # Populate the inventory with default values.\n        self.money = Money()\n        self.foos: list[Foo] = []\n        self.bars: list[Bar] = []\n        self.foobars: list[FooBar] = []\n        self.robots: list[Robot] = [\n            Robot.build(inventory=self) for _ in range(game_config.min_robots)\n        ]\n\n    def __str__(self) -&gt; str:\n        return f\"Inventory(foos={len(self.foos)}, bars={len(self.bars)}, foobars={len(self.foobars)}, robots={len(self.robots)}, money={self.money.value})\"\n\n    def get_ressource(\n        self,\n        ressource_name: IncrIdRessources,\n        lock: bool = True,\n    ) -&gt; IncrIdRessources | None:\n        ressources = getattr(self, ressource_name + \"s\")  # type: ignore\n        for ressource in ressources:\n            if ressource.lock:\n                continue\n            if lock:\n                ressource.lock = True\n            return ressource\n        return None\n\n    def get_ressources(\n        self,\n        ressource_name: IncrIdRessources,\n        count: int,\n        lock=True,\n    ) -&gt; list[IncrIdRessources]:\n        returned_ressources = []\n        ressources = getattr(self, ressource_name + \"s\")  # type: ignore\n        for ressource in ressources:\n            if ressource.lock:\n                continue\n            if lock:\n                ressource.lock = True\n            returned_ressources.append(ressource)\n            if len(returned_ressources) == count:\n                break\n\n        # Revert the lock when the count is not there.\n        if len(returned_ressources) != count:\n            for ressource in returned_ressources:\n                ressource.lock = False\n            return []\n\n        return returned_ressources\n\n    def on_new_transaction(self, transaction: Transaction) -&gt; None:\n        for model in transaction.add:\n            match model:\n                case Foo():\n                    self.foos.append(model)\n                case Bar():\n                    self.bars.append(model)\n                case FooBar():\n                    self.foobars.append(model)\n                case Robot():\n                    self.robots.append(model)\n                case Money():\n                    self.money += model\n\n        for model in transaction.remove:\n            match model:\n                case Foo():\n                    self.foos.remove(model)\n                case Bar():\n                    self.bars.remove(model)\n                case FooBar():\n                    self.foobars.remove(model)\n                case Robot():\n                    self.robots.remove(model)\n                case Money():\n                    self.money -= model\n</code></pre>"},{"location":"reference/#back.models.ressources","title":"<code>ressources</code>","text":""},{"location":"reference/#back.models.ressources.BaseRessource","title":"<code>BaseRessource</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>Base data model that can be listed in :class:<code>~back.models.transaction.Transaction</code>.</p> Source code in <code>src/back/models/ressources.py</code> <pre><code>class BaseRessource(BaseModel):\n    \"\"\"Base data model that can be listed in :class:`~back.models.transaction.Transaction`.\"\"\"\n\n    def __init_subclass__(cls, **kwargs):\n        \"\"\"Avoid having the error: \"Unable to extract tag using discriminator 'type'\"\n        at runtime. We directly see the problem at import time.\n        \"\"\"\n        # __init_subclass__ avoid having to use a metaclass in this use case\n        super().__init_subclass__(**kwargs)\n        if \"type\" not in cls.__dict__:\n            raise TypeError(f\"The class {cls.__name__} must have a 'type' field.\")\n</code></pre>"},{"location":"reference/#back.models.ressources.BaseRessource.__init_subclass__","title":"<code>__init_subclass__(**kwargs)</code>","text":"<p>Avoid having the error: \"Unable to extract tag using discriminator 'type'\" at runtime. We directly see the problem at import time.</p> Source code in <code>src/back/models/ressources.py</code> <pre><code>def __init_subclass__(cls, **kwargs):\n    \"\"\"Avoid having the error: \"Unable to extract tag using discriminator 'type'\"\n    at runtime. We directly see the problem at import time.\n    \"\"\"\n    # __init_subclass__ avoid having to use a metaclass in this use case\n    super().__init_subclass__(**kwargs)\n    if \"type\" not in cls.__dict__:\n        raise TypeError(f\"The class {cls.__name__} must have a 'type' field.\")\n</code></pre>"},{"location":"reference/#back.models.transaction","title":"<code>transaction</code>","text":""},{"location":"reference/#back.patterns","title":"<code>patterns</code>","text":""},{"location":"reference/#back.patterns.publish_subscribe","title":"<code>publish_subscribe</code>","text":""},{"location":"reference/#back.patterns.publish_subscribe.Provider","title":"<code>Provider</code>","text":"<p>Implementation of the Publish-Subscribe conversation pattern.</p> Source code in <code>src/back/patterns/publish_subscribe.py</code> <pre><code>class Provider:\n    \"\"\"Implementation of the Publish-Subscribe conversation pattern.\"\"\"\n\n    def __init__(self, *args, **kwargs) -&gt; None:\n        super().__init__(*args, **kwargs)\n        self._observers: dict[\n            type[\"EventType\"],\n            list[Callable[[\"EventType\"], None]],\n        ] = defaultdict(list)\n\n    def subscribe(\n        self,\n        event_type: type[\"EventType\"],\n        handler: Callable[[\"EventType\"], None],\n    ) -&gt; None:\n        self._observers[event_type].append(handler)\n\n    def unsubscribe(\n        self,\n        event_type: type[\"EventType\"],\n        handler: Callable[[\"EventType\"], None],\n    ) -&gt; None:\n        self._observers[event_type].remove(handler)\n\n    def _publish(self, event: \"EventType\") -&gt; None:\n        for handler in self._observers[type(event)]:\n            handler(event)\n</code></pre>"},{"location":"reference/#back.scheduler","title":"<code>scheduler</code>","text":""},{"location":"reference/#back.scheduler.Scheduler","title":"<code>Scheduler</code>","text":"<p>The game scheduler is not based on real timestamps, real delays, allowing for the scheduling of the next game turn directly after the previous one. Indeed, the primary objective of the game appears to be the construction of a trading model (using algorithms or machine learning), and the more parties we run, the better.</p> Source code in <code>src/back/scheduler.py</code> <pre><code>class Scheduler:\n    \"\"\"The game scheduler is not based on real timestamps, real delays, allowing for the scheduling of the next game turn\n    directly after the previous one. Indeed, the primary objective of the game appears to be the construction of a\n    trading model (using algorithms or machine learning), and the more parties we run, the better.\n    \"\"\"\n\n    __slots__ = [\"ts\", \"_tasks\"]\n\n    def __init__(self) -&gt; None:\n        self.ts = 0\n        # heapq is not thread safe and then, more optimal than synchronisation queues (sync or async)\n        self._tasks: list[Task] = []\n\n    def scheduleabs(\n        self,\n        timestamp: int,\n        action: Callable[..., Any],\n        *args,\n        **kwargs,\n    ) -&gt; None:\n        simplified_action = partial(action, *args, **kwargs)\n        heappush(self._tasks, Task(start_ts=timestamp, action=simplified_action))\n        log.debug(\n            f\"scheduling at {timestamp} action {action} with args={args} and kwargs={kwargs}\",\n        )\n\n    def schedule(\n        self,\n        delay: int,\n        action: Callable[..., Any],\n        *args,\n        **kwargs,\n    ) -&gt; None:\n        ts = self.ts + delay\n        self.scheduleabs(ts, action, *args, **kwargs)\n\n    def set_timestamp(self, timestamp: int) -&gt; None:\n        # log.debug(f\"now at {timestamp}\")\n        self.ts = timestamp\n        while self._tasks and (action_ts := self._tasks[0].start_ts) &lt;= self.ts:\n            log.debug(f\"executing action planned for {action_ts}\")\n            task: Task = heappop(self._tasks)\n            task.action()\n\n    def jump(self, delay: int) -&gt; None:\n        ts = self.ts + delay\n        self.set_timestamp(ts)\n\n    def reset(self) -&gt; None:\n        log.debug(\"resetting scheduler\")\n        self.ts = 0\n        self._tasks[:] = []\n\n    @contextmanager\n    def from_timestamp_contextmanager(self, ts: int):\n        \"\"\"Permit to change the now timestamp with a contextmanager.\n        so that child schedules do not depend on future time shifting.\n        \"\"\"\n        orig_ts = self.ts\n        # change now timestamp\n        self.ts = ts\n        try:\n            yield\n        finally:\n            # restore now timestamp\n            self.ts = orig_ts\n\n    def from_timestamp_decorator(self, ts: int):\n        \"\"\"Permit to change the now timestamp with a decorator\n        so that child schedules do not depend on future time shifting.\n        \"\"\"\n\n        def _from_timestamp_decorator(f):\n            @wraps(f)\n            def _from_timestamp_wrapper(*args, **kwargs):\n                with self.from_timestamp_contextmanager(ts):\n                    return f(*args, **kwargs)\n\n            return _from_timestamp_wrapper\n\n        return _from_timestamp_decorator\n\n    @property\n    def busy_until(self) -&gt; int | None:\n        return self._tasks[-1].start_ts if self._tasks else None\n</code></pre>"},{"location":"reference/#back.scheduler.Scheduler.from_timestamp_contextmanager","title":"<code>from_timestamp_contextmanager(ts)</code>","text":"<p>Permit to change the now timestamp with a contextmanager. so that child schedules do not depend on future time shifting.</p> Source code in <code>src/back/scheduler.py</code> <pre><code>@contextmanager\ndef from_timestamp_contextmanager(self, ts: int):\n    \"\"\"Permit to change the now timestamp with a contextmanager.\n    so that child schedules do not depend on future time shifting.\n    \"\"\"\n    orig_ts = self.ts\n    # change now timestamp\n    self.ts = ts\n    try:\n        yield\n    finally:\n        # restore now timestamp\n        self.ts = orig_ts\n</code></pre>"},{"location":"reference/#back.scheduler.Scheduler.from_timestamp_decorator","title":"<code>from_timestamp_decorator(ts)</code>","text":"<p>Permit to change the now timestamp with a decorator so that child schedules do not depend on future time shifting.</p> Source code in <code>src/back/scheduler.py</code> <pre><code>def from_timestamp_decorator(self, ts: int):\n    \"\"\"Permit to change the now timestamp with a decorator\n    so that child schedules do not depend on future time shifting.\n    \"\"\"\n\n    def _from_timestamp_decorator(f):\n        @wraps(f)\n        def _from_timestamp_wrapper(*args, **kwargs):\n            with self.from_timestamp_contextmanager(ts):\n                return f(*args, **kwargs)\n\n        return _from_timestamp_wrapper\n\n    return _from_timestamp_decorator\n</code></pre>"}]}